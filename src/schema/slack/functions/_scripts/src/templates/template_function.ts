import { isCustomType } from "../../../../../../types/mod.ts";
import SchemaTypes from "../../../../../schema_types.ts";
import SlackSchemaTypes from "../../../../schema_types.ts";
import { InternalSlackTypes } from "../../../../types/custom/mod.ts";
import {
  FunctionParameter,
  FunctionProperties,
  FunctionProperty,
  FunctionRecord,
} from "../types.ts";
import { isArrayFunctionProperty, isObjectFunctionProperty } from "../utils.ts";
import {
  autogeneratedComment,
  getSlackCallbackId,
  renderTypeImports,
  sanitize,
} from "./utils.ts";
import { AllowedTypeValue, AllowedTypeValueObject } from "./types.ts";

type AllowedHiddenParamsMap = Record<
  string,
  Record<"input" | "output", string[]>
>;
// Oops we accidentally exposed hidden parameters. That's ok, we'll keep them public for now.
export const allowedHiddenParams: AllowedHiddenParamsMap = {
  "open_form": {
    input: [],
    output: ["interactivity"],
  },
  "reply_in_thread": {
    input: ["files"],
    output: ["action", "interactivity"],
  },
  "send_dm": {
    input: ["files"],
    output: [
      "action",
      "interactivity",
      "timestamp_started",
      "timestamp_completed",
    ],
  },
  "send_message": {
    input: ["files"],
    output: [
      "action",
      "interactivity",
      "timestamp_started",
      "timestamp_completed",
    ],
  },
};

const typeMap: Record<string, AllowedTypeValueObject> = {
  SchemaTypes,
  SlackTypes: SlackSchemaTypes,
  InternalSlackTypes,
};

const schemaTypeMap = Object.entries(typeMap).reduce<Record<string, string>>(
  (acc, [schemaKey, schemaTypes]) => {
    for (const schemaType in schemaTypes) {
      const value: AllowedTypeValue = schemaTypes[schemaType];
      const type: string = isCustomType(value) ? value.id : value;
      acc[type] = `${schemaKey}.${schemaType}`;
    }
    return acc;
  },
  {},
);

const propertyToTypeScript = (
  property: FunctionProperty,
): string => {
  const typescript = [];
  const sdkType = schemaTypeMap[property.type];
  if (!sdkType) {
    throw new Error(
      `Unrecognized type "${property.type}"! Maybe a new automation platform type was recently introduced? If so, add it to one of the type files under src/schema.`,
    );
  }
  typescript.push(
    `type: ${sdkType}`,
  );
  if (property.description) {
    typescript.push(`description: ${sanitize(property.description)}`);
  }
  if (property.title) {
    typescript.push(`title: ${sanitize(property.title)}`);
  }
  if (isArrayFunctionProperty(property)) {
    typescript.push(`items: ${propertyToTypeScript(property.items)}`);
  }
  if (isObjectFunctionProperty(property)) {
    typescript.push(
      `properties: ${propertiesToTypeScript(property.properties)}`,
    );
    typescript.push(
      `additionalProperties: ${property.additionalProperties ?? true}`,
    );
    typescript.push(`required: ${JSON.stringify(property.required ?? [])}`);
  }
  return `{${typescript.join(",\n")}}`;
};

const propertiesToTypeScript = (
  properties: FunctionProperties,
) => {
  const typescript: string[] = [];
  Object.entries(properties).forEach(([propertyKey, property]) => {
    typescript.push(
      `${propertyKey}: ${propertyToTypeScript(property)}`,
    );
  });
  return `{${typescript.join(",\n")}}`;
};

const manifestParametersToTypeScript = (
  allowedHiddenParams: string[],
  functionParameters: FunctionParameter[],
) => {
  const typescript: string[] = [];
  typescript.push(
    `properties: {${
      functionParameters.filter((p) =>
        allowedHiddenParams.includes(p.name) || !p.is_hidden
      ).map((parameter) =>
        `${parameter.name}: ${propertyToTypeScript(parameter)}`
      ).join(",\n")
    }}`,
  );
  typescript.push(`required: ${
    JSON.stringify(
      functionParameters.filter((p) => p.is_required).map(
        (p) => p.name,
      ),
    )
  }`);
  return `{${typescript.join(",\n")}}`;
};

export function manifestFunctionFieldsToTypeScript(
  allowedParamsMap: AllowedHiddenParamsMap,
  functionRecord: FunctionRecord,
) {
  const typescript: string[] = [];
  typescript.push(`source_file: ""`);
  if (functionRecord.title) {
    typescript.push(
      `title: ${sanitize(functionRecord.title)}`,
    );
  }
  if (functionRecord.description) {
    typescript.push(
      `description: ${sanitize(functionRecord.description)}`,
    );
  }
  const allowedHiddenParams = allowedParamsMap[functionRecord.callback_id] ||
    { input: [], output: [] };
  typescript.push(
    `input_parameters: ${
      manifestParametersToTypeScript(
        allowedHiddenParams.input,
        functionRecord.input_parameters,
      )
    }`,
  );
  typescript.push(
    `output_parameters: ${
      manifestParametersToTypeScript(
        allowedHiddenParams.output,
        functionRecord.output_parameters,
      )
    }`,
  );
  return typescript.join(",\n");
}

const defineFunctionInputToTypeScript = (
  functionRecord: FunctionRecord,
) => {
  const typescript: string[] = [];
  typescript.push(
    `callback_id: ${sanitize(getSlackCallbackId(functionRecord))}`,
  );
  typescript.push(
    manifestFunctionFieldsToTypeScript(allowedHiddenParams, functionRecord),
  );
  return `{${typescript.join(",\n")}}`;
};

export function SlackFunctionTemplate(
  functionRecord: FunctionRecord,
): string {
  const typescript: string[] = [];
  typescript.push(autogeneratedComment());
  typescript.push(
    `import { DefineFunction } from "../../../functions/mod.ts";`,
  );
  typescript.push(renderTypeImports(functionRecord));
  typescript.push("");
  typescript.push(
    `export default DefineFunction(${
      defineFunctionInputToTypeScript(functionRecord)
    });`,
  );

  return typescript.join("\n");
}

export default SlackFunctionTemplate;
