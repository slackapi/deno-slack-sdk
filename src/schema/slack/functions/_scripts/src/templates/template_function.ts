import { ParameterSetDefinition } from "../../../../../../parameters/types.ts";
import { ParameterDefinition } from "../../../../../../parameters/definition_types.ts";
import {
  ManifestFunctionParameters,
  ManifestFunctionSchema,
} from "../../../../../../manifest/manifest_schema.ts";
import { ICustomType } from "../../../../../../types/types.ts";
import SchemaTypes from "../../../../../schema_types.ts";
import SlackSchemaTypes from "../../../../schema_types.ts";
import { InternalSlackTypes } from "../../../../types/custom/mod.ts";
import { DefineFunctionInput } from "../types.ts";
import { getSlackCallbackId } from "./template_utils.ts";
import { autogeneratedComment } from "./template_utils.ts";

type AllowedTypeValue = ICustomType | string;
type AllowedTypeValueObject = Record<string, AllowedTypeValue>;

const typeMap: Record<string, AllowedTypeValueObject> = {
  SchemaTypes,
  SlackTypes: SlackSchemaTypes,
  InternalSlackTypes,
};

const schemaTypeMap = Object.entries(typeMap).reduce<AllowedTypeValueObject>(
  (acc, [schemaKey, schemaTypes]) => {
    for (const typeKey in schemaTypes) {
      const val = schemaTypes[typeKey];
      if (val instanceof Object) {
        acc[val.id] = `${schemaKey}.${typeKey}`;
      } else {
        acc[val] = `${schemaKey}.${typeKey}`;
      }
    }
    return acc;
  },
  {},
);

const getParamType = (type: string | ICustomType): string =>
  type instanceof Object ? type.id : type;

/** @description returns a list of all fn parameters */
const getParameterList = (fn: DefineFunctionInput) => [
  ...Object.entries(fn.input_parameters.properties).map(([_key, value]) =>
    value
  ),
  ...Object.entries(fn.output_parameters.properties).map(([_key, value]) =>
    value
  ),
];

/** @description Whether or not a fn uses parameters from a defined type object */
const hasParamsFromTypeObject = (
  fn: DefineFunctionInput,
  typeObject: AllowedTypeValueObject,
) =>
  getParameterList(fn).some((param) =>
    Object.values(typeObject)
      .map((val) => getParamType(val))
      .includes(getParamType(param.type))
  );

const propertyToTypeScript = (
  property: ParameterDefinition,
): string => {
  const typescript = [];
  typescript.push(
    `type: ${schemaTypeMap[getParamType(property.type)]}`,
  );
  if ("description" in property) {
    typescript.push(`description: "${property.description}"`);
  }
  if ("properties" in property) {
    if ("additionalProperties" in property) {
      typescript.push(`additionalProperties: ${property.additionalProperties}`);
    }
    if ("required" in property) {
      typescript.push(`required: ${JSON.stringify(property.required)}`);
    }
    typescript.push(
      `properties: ${propertiesToTypeScript(property["properties"])}`,
    );
  }
  return typescript.join(",\n");
};

const propertiesToTypeScript = (
  properties: ParameterSetDefinition,
) => {
  const typescript: string[] = [];
  Object.entries(properties).forEach(([propertyKey, propertyValue]) => {
    typescript.push(
      `${propertyKey}: {${propertyToTypeScript(propertyValue)}}`,
    );
  });
  return `{${typescript.join(",\n")}}`;
};

const manifestParametersToTypeScript = (
  parameters: ManifestFunctionParameters,
) => {
  const typescript: string[] = [];
  typescript.push(
    `properties: ${propertiesToTypeScript(parameters.properties)}`,
  );
  if (parameters.required) {
    typescript.push(`required: ${JSON.stringify(parameters.required)}`);
  }
  return `{${typescript.join(",\n")}}`;
};

export const manifestFunctionFieldsToTypeScript = <
  M extends ManifestFunctionSchema,
>(
  manifestFunctionSchema: M,
) => {
  const typescript: string[] = [];
  typescript.push(`source_file: "${manifestFunctionSchema.source_file}"`);
  if (manifestFunctionSchema.title) {
    typescript.push(`title: "${manifestFunctionSchema.title}"`);
  }
  if (manifestFunctionSchema.description) {
    typescript.push(`description: "${manifestFunctionSchema.description}"`);
  }
  typescript.push(
    `input_parameters: ${
      manifestParametersToTypeScript(manifestFunctionSchema.input_parameters)
    }`,
  );
  typescript.push(
    `output_parameters: ${
      manifestParametersToTypeScript(manifestFunctionSchema.output_parameters)
    }`,
  );
  return typescript.join(",\n");
};

const defineFunctionInputToTypeScript = (
  defineFunctionInput: DefineFunctionInput,
) => {
  const typescript: string[] = [];
  typescript.push(
    `callback_id: "${getSlackCallbackId(defineFunctionInput)}"`,
  );
  typescript.push(manifestFunctionFieldsToTypeScript(defineFunctionInput));
  return `{${typescript.join(",\n")}}`;
};

export const renderTypeImports = (dfi: DefineFunctionInput) => {
  const typescript: string[] = [];
  if (hasParamsFromTypeObject(dfi, SchemaTypes)) {
    typescript.push('import SchemaTypes from "../../schema_types.ts";');
  }
  if (hasParamsFromTypeObject(dfi, SlackSchemaTypes)) {
    typescript.push('import SlackTypes from "../schema_types.ts";');
  }
  if (hasParamsFromTypeObject(dfi, InternalSlackTypes)) {
    typescript.push(
      'import { InternalSlackTypes } from "../types/custom/mod.ts";',
    );
  }
  return typescript.join("\n");
};

export function SlackFunctionTemplate(
  defineFunctionInput: DefineFunctionInput,
): string {
  const typescript: string[] = [];
  typescript.push(autogeneratedComment());
  typescript.push(
    `import { DefineFunction } from "../../../functions/mod.ts";`,
  );
  typescript.push(renderTypeImports(defineFunctionInput));
  typescript.push("");
  typescript.push(
    `export default DefineFunction(${
      defineFunctionInputToTypeScript(defineFunctionInput)
    });`,
  );

  return typescript.join("\n");
}

export default SlackFunctionTemplate;
