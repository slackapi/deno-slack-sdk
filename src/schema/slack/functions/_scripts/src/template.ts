import { pascalCase } from "https://deno.land/x/case@v2.1.0/mod.ts";
import {
  ParameterVariableType,
  ParameterSetDefinition,
} from "../../../../../parameters/mod.ts";
import {
  ManifestFunctionParameters,
  ManifestFunctionSchema,
} from "../../../../../manifest/manifest_schema.ts";
import { ICustomType } from "../../../../../types/types.ts";
import SchemaTypes from "../../../../schema_types.ts";
import SlackSchemaTypes from "../../../schema_types.ts";
import { InternalSlackTypes } from "../../../types/custom/mod.ts";
import { FunctionParameter, FunctionRecord } from "./types.ts";

type AllowedTypeValue = ICustomType | string;
type AllowedTypeValueObject = Record<string, AllowedTypeValue>;

const autogeneratedComment = () => {
  const time = new Date();
  return `/** This file was autogenerated on ${time.toDateString()}. Follow the steps in src/schema/slack/functions/README.md to rebuild **/`;
};

const templatizeRequiredParams = (params: FunctionParameter[]) => {
  const requiredParams: string[] = params.filter((p) => p.is_required).map(
    (p) => p.name !== undefined ? p.name : "",
  );

  return requiredParams;
};

const templatizeParams = (
  params: FunctionParameter[],
  useTypeValue = false,
) => {
  const paramEntries = params.map((p) => templatizeParam(p, useTypeValue)).join(
    ",",
  );
  console.log(`{ ${paramEntries} }`);
  return JSON.parse(`{ ${paramEntries} }`);
};

const getProperties = (
  params: FunctionParameter[],
  useTypeValue = false,
) => {
  const properties: { [k: string]: any } = {};
  params.forEach((p) => {
    properties[p.name !== undefined ? p.name : ""] = getParamDef(
      p,
      useTypeValue,
    );
  });
  // const paramEntries = params.map((p) => templatizeParam(p, useTypeValue)).join(
  //   ",",
  // );
  // console.log(`{ ${paramEntries} }`);
  console.log(properties);
  return properties;
};

const templatizeParam = (param: FunctionParameter, useTypeValue = false) => {
  const paramDef = getParamDef(param, useTypeValue);
  return `${param.name}: ${paramDef}`;
};

const typeMap: Record<string, AllowedTypeValueObject> = {
  SchemaTypes,
  SlackTypes: SlackSchemaTypes,
  InternalSlackTypes,
};

const schemaTypeMap = Object.entries(typeMap).reduce<AllowedTypeValueObject>(
  (acc, [schemaKey, schemaTypes]) => {
    for (const typeKey in schemaTypes) {
      const val = schemaTypes[typeKey];
      if (val instanceof Object) {
        acc[val.id] = `${schemaKey}.${typeKey}`;
      } else {
        acc[val] = `${schemaKey}.${typeKey}`;
      }
    }
    return acc;
  },
  {},
);

const getParamDef = (param: FunctionParameter, useTypeValue = false) => {
  const paramDef: { [k: string]: any } = {
    type: useTypeValue
      ? `"${param.type}"`
      : schemaTypeMap[getParamType(param.type)],
  };
  if (param.description) {
    paramDef.description = param.description;
  }
  if (param.properties) {
    paramDef.properties = {};
    Object.entries(param.properties).forEach(([propertyKey, propertyValue]) => {
      paramDef.properties[propertyKey] = getParamDef(propertyValue, false);
    });
  }
  if (param.items) {
    paramDef.items = {
      type: param.items.type,
    };
  }
  return paramDef;
};

const getSchemaTypeImport = (fn: FunctionRecord) =>
  hasParamsFromTypeObject(fn, SchemaTypes)
    ? 'import SchemaTypes from "../../schema_types.ts";'
    : "";

const getSlackSchemaTypeImport = (fn: FunctionRecord) =>
  hasParamsFromTypeObject(fn, SlackSchemaTypes)
    ? 'import SlackTypes from "../schema_types.ts";'
    : "";

const getInternalSlackSchemaTypeImport = (fn: FunctionRecord) =>
  hasParamsFromTypeObject(fn, InternalSlackTypes)
    ? 'import { InternalSlackTypes } from "../types/custom/mod.ts";'
    : "";

const getParamType = (type: string | ICustomType): string =>
  type instanceof Object ? type.id : type;

/** @description returns a list of all fn parameters */
const getParameterList = (fn: FunctionRecord) => [
  ...fn?.input_parameters ?? [],
  ...fn?.output_parameters ?? [],
];

/** @description Whether or not a fn uses parameters from a defined type object */
const hasParamsFromTypeObject = (
  fn: FunctionRecord,
  typeObject: AllowedTypeValueObject,
) =>
  getParameterList(fn)
    .some((param) =>
      Object.values(typeObject)
        .map((val) => getParamType(val))
        .includes(getParamType(param.type))
    );

    function propertyToTypeScriptString<ParameterVariableType>(property: ParameterVariableType){
      let typescriptString = `{
        type: ${getParamType(property.type)}`;
      if (property.description) {
        typescriptString += `,
        description: "${property.description}"`;
      }
      if (property.)
      typescriptString += `}`;
      return typescriptString;
    }
    
const propertiesToTypeScriptString = (
  properties: ParameterSetDefinition,
) => {
  let typescriptString = `{`;
  Object.entries(properties).forEach(([propertyKey, propertyValue]) => {
    typescriptString += `${propertyKey}: ${
      propertyToTypeScriptString(propertyValue)
    },
    `;
  });
  typescriptString += `}`;
  return typescriptString;
};

const parametersToTypeScriptString = (
  parameters: ManifestFunctionParameters,
) => {
  let typescriptString = `{`;
  typescriptString += `
      properties: ${propertiesToTypeScriptString(parameters.properties)}`;
  if (parameters.required) {
    typescriptString += `,
      required: ${JSON.stringify(parameters.required)}`;
  }
  typescriptString += `
    }`;
  return typescriptString;
};

const functionToTypeScriptString = (
  callback_id: string,
  manifestFunctionSchema: ManifestFunctionSchema,
) => {
  let typescriptString = `{
    callback_id: "${callback_id}",
    source_file: "${manifestFunctionSchema.source_file}"`;
  if (manifestFunctionSchema.title) {
    typescriptString += `,
    title: "${manifestFunctionSchema.title}"`;
  }
  if (manifestFunctionSchema.description) {
    typescriptString += `,
    description: "${manifestFunctionSchema.description}"`;
  }
  typescriptString += `,
    input_parameters: ${
    parametersToTypeScriptString(manifestFunctionSchema.input_parameters)
  },
    output_parameters: ${
    parametersToTypeScriptString(manifestFunctionSchema.output_parameters)
  }
}`;
  return typescriptString;
};

export const getManifestFunctionSchemaFields = (fn: FunctionRecord) => {
  const ManifestFunctionSchemaFields: ManifestFunctionSchema = {
    source_file: "",
    title: fn.title,
    description: fn.description,
    input_parameters: {
      required: templatizeRequiredParams(fn.input_parameters),
      properties: getProperties(fn.input_parameters, false),
    },
    output_parameters: {
      required: templatizeRequiredParams(fn.output_parameters),
      properties: getProperties(fn.output_parameters, false),
    },
  };
  // // let paramsString = "";
  // if (fn.input_parameters) {
  //   ManifestFunctionSchemaFields.input_parameters = {
  //     required: templatizeRequiredParams(fn.input_parameters),
  //     properties: getProperties(fn.input_parameters, false),
  //   };
  //   //     paramsString = `
  //   // input_parameters: {
  //   //   required: ${templatizeRequiredParams(fn.input_parameters)},
  //   //   properties: ${templatizeParams(fn.input_parameters, false)}
  //   // }`;
  // }
  // if (fn.output_parameters) {
  //   ManifestFunctionSchemaFields.output_parameters = {
  //     required: templatizeRequiredParams(fn.output_parameters),
  //     properties: getProperties(fn.output_parameters, false),
  //   };
  //   //     if (paramsString !== "") {
  //   //       paramsString += ",";
  //   //     }
  //   //     paramsString += `
  //   // output_parameters: {
  //   //   required: ${templatizeRequiredParams(fn.output_parameters)},
  //   //   properties: ${templatizeParams(fn.output_parameters, false)}
  //   // }`;
  // }
  return ManifestFunctionSchemaFields;
};

export const SlackFunctionTemplate = (fn: FunctionRecord) => {
  const schemaTypesImport = getSchemaTypeImport(fn);
  const slackSchemaTypesImport = getSlackSchemaTypeImport(fn);
  const internalSlackSchemaTypesImport = getInternalSlackSchemaTypeImport(fn);
  const manifestFunctionSchemaFields = getManifestFunctionSchemaFields(fn);
  return `
    ${autogeneratedComment()}
    import { DefineFunction } from "../../../functions/mod.ts";${schemaTypesImport}${slackSchemaTypesImport}${internalSlackSchemaTypesImport}

    export default DefineFunction(${
    functionToTypeScriptString(
      `slack#/functions/${fn.callback_id}`,
      manifestFunctionSchemaFields,
    )
  });
  `;
};

export const SlackFunctionModTemplate = (slackFunctions: FunctionRecord[]) => {
  const callbackIds = slackFunctions.map((fn) => fn.callback_id);
  const importStrings = callbackIds.map(renderImport).join("\n");

  const functionProps = slackFunctions.map((fn) =>
    renderFunctionPropWithType(fn)
  )
    .join(",");

  return `
    ${autogeneratedComment()}
    ${importStrings}

    const SlackFunctions = {
      ${functionProps}
    } as const;

    export default SlackFunctions;
  `;
};

export const getFunctionName = (callbackId: string) => {
  return pascalCase(callbackId);
};

export const renderImport = (callbackId: string) => {
  return `import ${getFunctionName(callbackId)} from "./${callbackId}.ts";`;
};

const renderFunctionPropWithType = (fn: FunctionRecord) => {
  return `${getFunctionName(fn.callback_id)}: ${
    getFunctionName(fn.callback_id)
  }`;
};
